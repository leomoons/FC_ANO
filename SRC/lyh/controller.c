 /**********************************************************************************************************
 * @文件     controller.c
 * @说明     控制器总和
 * @版本  	 V1.0
 * @作者     Leomoon
 * @日期     2020.12
**********************************************************************************************************/
#include "controller.h"
#include "Ano_RC.h"
#include "Ano_Imu.h"
#include "Ano_Sensor_Basic.h"

#include "pd.h"
#include "smc.h"
#include "flightMode.h"
#include "SetPoint.h"
#include "disturbanceEst.h"
#include "ros.h"
#include "mat.h"

vehicle_para_t _veh;
control_set_t _ctrl_only;		// control set generated by only controller
control_set_t _ctrl;				// control set (sum of controller and estimator)
droneState_t _state;


#define MAX_POS_DES	4	//手动飞行中摇杆所能对应的最大位置误差（单位：m）
#define MAX_ATT_DES	1.57	//手动飞行中摇杆所能对应的最大角度误差（单位:rad）
#define VEL_DEFAULT 0.5	//手动飞行中默认的线速度大小(m/s)
#define ANG_VEL_DEFAULT 0.1	//手动飞行中默认的角速度大小(rad/s)

enum
{
	IMU_EST,
	OPTITRACK_IN
};

enum
{
	PD,
	SMC
};

enum
{
	UP,
	DOWN
};

#define FEEDBACK_SRC	IMU_EST
#define CONTROLLER SMC
#define BODYFRAME UP

/**********************************************************************************************************
*函 数 名: ControllerInit
*功能说明: 控制器参数初始化
*形    参: 无
*返 回 值: 无
**********************************************************************************************************/
void ControllerInit(void)
{
	/***********机身物理参数初始化***********************/
	//inerita matrix
	_veh.J[0]=0.0444f;	_veh.J[1]=  0.0f;	 	_veh.J[2]=   0.0f;
	_veh.J[3]=   0.0f;  _veh.J[4]=0.0434f;	_veh.J[5]=   0.0f;
	_veh.J[6]=   0.0f;	_veh.J[7]=  0.0f;		_veh.J[8]=0.0756f;
	
	_veh.J_inv[0]=22.5225f;	_veh.J_inv[1]=    0.0f; _veh.J_inv[2]=    0.0f;
	_veh.J_inv[3]=    0.0f; _veh.J_inv[4]=23.0415f;	_veh.J_inv[5]=    0.0f;
	_veh.J_inv[6]=    0.0f;	_veh.J_inv[7]=    0.0f;	_veh.J_inv[8]=13.2275f;
	
	//_veh.mass = 0.8846f;
	//_veh.mass = 1.08f;
	_veh.mass = 1.3f;			//提高这个用于姿态测试时电机尽量不反转
	
	// inverse of control allocation matrix 30度倾角
//	_veh.Binv[0][0]=      0; _veh.Binv[0][1]= 0.6667; _veh.Binv[0][2]= 0.1925; _veh.Binv[0][3]=      0; _veh.Binv[0][4]=-1.1207; _veh.Binv[0][5]= 0.8555;
//	_veh.Binv[1][0]= 0.5774; _veh.Binv[1][1]=-0.3333; _veh.Binv[1][2]= 0.1925; _veh.Binv[1][3]= 0.9705; _veh.Binv[1][4]=-0.5603; _veh.Binv[1][5]=-0.8555;
//	_veh.Binv[2][0]=-0.5774; _veh.Binv[2][1]=-0.3333; _veh.Binv[2][2]= 0.1925; _veh.Binv[2][3]= 0.9705; _veh.Binv[2][4]= 0.5603; _veh.Binv[2][5]= 0.8555;
//	_veh.Binv[3][0]=      0; _veh.Binv[3][1]= 0.6667; _veh.Binv[3][2]= 0.1925; _veh.Binv[3][3]=      0; _veh.Binv[3][4]= 1.1207; _veh.Binv[3][5]=-0.8555;
//	_veh.Binv[4][0]= 0.5774; _veh.Binv[4][1]=-0.3333; _veh.Binv[4][2]= 0.1925; _veh.Binv[4][3]=-0.9705; _veh.Binv[4][4]= 0.5603; _veh.Binv[4][5]= 0.8555;
//	_veh.Binv[5][0]=-0.5774; _veh.Binv[5][1]=-0.3333; _veh.Binv[5][2]= 0.1925; _veh.Binv[5][3]=-0.9705; _veh.Binv[5][4]=-0.5603; _veh.Binv[5][5]=-0.8555;

	// 40度倾角
	_veh.Binv[0][0]=      0; _veh.Binv[0][1]= 0.5186; _veh.Binv[0][2]= 0.2176; _veh.Binv[0][3]=      0; _veh.Binv[0][4]=-1.2605; _veh.Binv[0][5]= 0.6720;
	_veh.Binv[1][0]= 0.4491; _veh.Binv[1][1]=-0.2593; _veh.Binv[1][2]= 0.2176; _veh.Binv[1][3]= 1.0916; _veh.Binv[1][4]=-0.6302; _veh.Binv[1][5]=-0.6720;
	_veh.Binv[2][0]=-0.4491; _veh.Binv[2][1]=-0.2593; _veh.Binv[2][2]= 0.2176; _veh.Binv[2][3]= 1.0916; _veh.Binv[2][4]= 0.6302; _veh.Binv[2][5]= 0.6720;
	_veh.Binv[3][0]=      0; _veh.Binv[3][1]= 0.5186; _veh.Binv[3][2]= 0.2176; _veh.Binv[3][3]=      0; _veh.Binv[3][4]= 1.2605; _veh.Binv[3][5]=-0.6720;
	_veh.Binv[4][0]= 0.4491; _veh.Binv[4][1]=-0.2593; _veh.Binv[4][2]= 0.2176; _veh.Binv[4][3]=-1.0916; _veh.Binv[4][4]= 0.6302; _veh.Binv[4][5]= 0.6720;
	_veh.Binv[5][0]=-0.4491; _veh.Binv[5][1]=-0.2593; _veh.Binv[5][2]= 0.2176; _veh.Binv[5][3]=-1.0916; _veh.Binv[5][4]=-0.6302; _veh.Binv[5][5]=-0.6720;

	
	
	// 45度倾角
//	_veh.Binv[0][0]=      0; _veh.Binv[0][1]= 0.4714; _veh.Binv[0][2]= 0.2357; _veh.Binv[0][3]=      0; _veh.Binv[0][4]=-1.4072; _veh.Binv[0][5]= 0.6285;
//	_veh.Binv[1][0]= 0.4082; _veh.Binv[1][1]=-0.2357; _veh.Binv[1][2]= 0.2357; _veh.Binv[1][3]= 1.2187; _veh.Binv[1][4]=-0.7036; _veh.Binv[1][5]=-0.6285;
//	_veh.Binv[2][0]=-0.4082; _veh.Binv[2][1]=-0.2357; _veh.Binv[2][2]= 0.2357; _veh.Binv[2][3]= 1.2187; _veh.Binv[2][4]= 0.7036; _veh.Binv[2][5]= 0.6285;
//	_veh.Binv[3][0]=      0; _veh.Binv[3][1]= 0.4714; _veh.Binv[3][2]= 0.2357; _veh.Binv[3][3]=      0; _veh.Binv[3][4]= 1.4072; _veh.Binv[3][5]=-0.6285;
//	_veh.Binv[4][0]= 0.4082; _veh.Binv[4][1]=-0.2357; _veh.Binv[4][2]= 0.2357; _veh.Binv[4][3]=-1.2187; _veh.Binv[4][4]= 0.7036; _veh.Binv[4][5]= 0.6285;
//	_veh.Binv[5][0]=-0.4082; _veh.Binv[5][1]=-0.2357; _veh.Binv[5][2]= 0.2357; _veh.Binv[5][3]=-1.2187; _veh.Binv[5][4]=-0.7036; _veh.Binv[5][5]=-0.6285;

	_ctrl.F_b.x=0.0f; _ctrl.F_b.y=0.0f; _ctrl.F_b.z=0.0f;
	_ctrl.M_b.x=0.0f; _ctrl.M_b.y=0.0f; _ctrl.M_b.z=0.0f;

	if(BODYFRAME == UP)
	{
		//_veh.T = -0.0063f;
		_veh.T = -0.0072f;
	}
	else if(BODYFRAME == DOWN)
	{
		_veh.T = 0.0063f;
	}
	
	
	// controller choosing
	if(CONTROLLER == PD)
	{
		pdCtrlInit();
	}
	else if(CONTROLLER == SMC)
	{
		smcCtrlInit();
	}
	
	// disturbance estimating module initilize
	estimatorInit();
	
}

/**********************************************************************************************************
*函 数 名: CtrlTask
*功能说明: 控制器主函数
*形    参: 无
*返 回 值: 无
**********************************************************************************************************/
void CtrlTask(void)
{
	/*******Manual模式不接受ros提供位置反馈，Mission模式接受***********/
	//Manual模式：期望姿态<-遥控器，反馈姿态<-IMU。期望位置<-遥控器，反馈位置<-[0;0;0]
	if(GetFlightMode() == MANUAL)
	{
		//遥控期望最大值
		float max_pos_des = MAX_POS_DES;
		float max_att_des = MAX_ATT_DES;
		// float vel_default = VEL_DEFAULT;
		float W_default = ANG_VEL_DEFAULT;
		int16_t _deadzone = 50;		//遥控信号死区
		
		Vector3f_t att_des;
		
		// 遥控通道值归一化
		_state.pos_des.x = ApplyDeadbandFloat(CH_N[CH7], _deadzone)*0.0023f*max_pos_des;
		_state.pos_des.y = ApplyDeadbandFloat(CH_N[CH8], _deadzone)*0.0023f*max_pos_des;
		_state.pos_des.z = ApplyDeadbandFloat(CH_N[CH3], _deadzone)*0.0023f*max_pos_des;
		att_des.x = ApplyDeadbandFloat(CH_N[CH1], _deadzone)*0.0023f*max_att_des;
		att_des.y = ApplyDeadbandFloat(CH_N[CH2], _deadzone)*0.0023f*max_att_des;
		att_des.z =-ApplyDeadbandFloat(CH_N[CH4], _deadzone)*0.0023f*max_att_des;
		
		//期望速度，期望加速度
		_state.vel_des.x = 0.0f; _state.vel_des.y = 0.0f; _state.vel_des.z = 0.0f;
		_state.acc_des.x = 0.0f; _state.acc_des.y = 0.0f; _state.acc_des.z = 0.0f;
		
		//期望姿态的DCM和四元数
		Euler_to_DCM(_state.R_des, att_des);
		DCM_to_Quater(_state.q_des, _state.R_des);
		
		//根据期望的欧拉角度来生成相应角速度
		if(att_des.x<0)		_state.W_des.x = -W_default;
		else if(att_des.x==0)	_state.W_des.x = 0.0f;
		else							_state.W_des.x = W_default;
		if(att_des.y<0)		_state.W_des.y = -W_default;
		else if(att_des.y==0)	_state.W_des.y = 0.0f;
		else							_state.W_des.y = W_default;
		if(att_des.z<0)		_state.W_des.z = -W_default;
		else if(att_des.z==0)	_state.W_des.z = 0.0f;
		else							_state.W_des.z = W_default;
		
		//期望角加速度
		_state.W_dot_des.x = 0.0f; _state.W_dot_des.y = 0.0f; _state.W_dot_des.z = 0.0f;
		
		
		//反馈的位置和速度，都取零
		_state.pos_fb.x = 0.0f; _state.pos_fb.y = 0.0f; _state.pos_fb.z = 0.0f;
		_state.vel_fb.x = 0.0f; _state.vel_fb.y = 0.0f; _state.vel_fb.z = 0.0f;
	}
	//Mission模式：期望姿态<-Setpoint模块，反馈姿态<-IMU。期望位置<-ros，反馈位置<-ros
	else if(GetFlightMode() == MISSION || GetFlightMode() == OBSERVER)
	{
		//由ros端提供所有位置相关数据，期望和反馈
//		_state.pos_des = GetRosPosDes();
//		_state.pos_fb = GetRosPosFb();
//		_state.vel_des = GetRosVelDes();
//		_state.vel_fb = GetRosVelFb();
//		_state.acc_des = GetRosAccDes();
//		
		//光测试姿态的轨迹跟踪时，位置所有状态量为零
		
		
		//期望姿态轨迹由SetPoint模块生成
		GetDesiredAtt(_state.R_des);
		DCM_to_Quater(_state.q_des, _state.R_des);
		_state.euler_des = DCM_to_Euler_degree(_state.R_des);
		GetDesiredAngVel(&_state.W_des);
		GetDesiredAngAcc(&_state.W_dot_des);
	}
	
	//反馈姿态和角速度，来自IMU解算，角度单位(rad)
	if(BODYFRAME == UP)
	{
		_state.R_fb[0]=att_matrix[0][0]; _state.R_fb[1]=att_matrix[0][1]; _state.R_fb[2]=att_matrix[0][2]; 
		_state.R_fb[3]=att_matrix[1][0]; _state.R_fb[4]=att_matrix[1][1]; _state.R_fb[5]=att_matrix[1][2]; 
		_state.R_fb[6]=att_matrix[2][0]; _state.R_fb[7]=att_matrix[2][1]; _state.R_fb[8]=att_matrix[2][2]; 
			
		_state.W_fb.x = sensor.Gyro_rad[X];
		_state.W_fb.y = sensor.Gyro_rad[Y];
		_state.W_fb.z = sensor.Gyro_rad[Z];	
	}
	else if(BODYFRAME == DOWN)
	{
		_state.R_fb[0]=att_matrix[0][0]; _state.R_fb[1]=-att_matrix[0][1]; _state.R_fb[2]=-att_matrix[0][2]; 
		_state.R_fb[3]=att_matrix[1][0]; _state.R_fb[4]=-att_matrix[1][1]; _state.R_fb[5]=-att_matrix[1][2]; 
		_state.R_fb[6]=att_matrix[2][0]; _state.R_fb[7]=-att_matrix[2][1]; _state.R_fb[8]=-att_matrix[2][2]; 
			
		_state.W_fb.x = sensor.Gyro_rad[X];
		_state.W_fb.y =-sensor.Gyro_rad[Y];
		_state.W_fb.z =-sensor.Gyro_rad[Z];
	}
		
	//计算欧拉角形式姿态
	_state.euler_fb = DCM_to_Euler_degree(_state.R_fb);
	_state.euler_fb.x =-_state.euler_fb.x;
	_state.euler_fb.z =-_state.euler_fb.z;
		
	//计算四元数形式姿态
	DCM_to_Quater(_state.q_fb, _state.R_fb);
		
	/*********************硬件在环仿真***********************/
//	_state.pos_des = GetMatPosDes();
//	_state.vel_des = GetMatVelDes();
//	_state.acc_des = GetMatAccDes();
//	_state.pos_fb = GetMatPosFb();
//	_state.vel_fb = GetMatVelFb();
//	
//	GetMatDcmDes(_state.R_des);
//	GetMatDcmFb(_state.R_fb);
//	_state.W_des = GetMatWDes();
//	_state.W_fb = GetMatWFb();
//	_state.W_dot_des = GetMatWdotDes();
	
	
	
	
	/************控制器选择:  1.PD  2.SMC****************/
	if(CONTROLLER == PD)
	{
		pdCtrlUpdate();
	}
	else if(CONTROLLER == SMC)
	{
		smcCtrlUpdate();
	}
	
	/****扰动估计输出***/
	estimatorOutput();

	
	// 加和控制器和扰动估计器的控制量
	//_ctrl.F_b = Vector3f_Sub(_ctrl_only.F_b, _est.F_b);		//姿态测试时不添加
	_ctrl.F_b.x = _ctrl_only.F_b.x;_ctrl.F_b.y = _ctrl_only.F_b.y;_ctrl.F_b.z = _ctrl_only.F_b.z;
	_ctrl.M_b = Vector3f_Sub(_ctrl_only.M_b, _est.M_b);
	_ctrl.wrench[0] = _ctrl.F_b.x;
	_ctrl.wrench[1] = _ctrl.F_b.y;
	_ctrl.wrench[2] = _ctrl.F_b.z;
	_ctrl.wrench[3] = _ctrl.M_b.x;
	_ctrl.wrench[4] = _ctrl.M_b.y;
	_ctrl.wrench[5] = _ctrl.M_b.z;
	
	/****扰动估计更新***/
	estimatorUpdate();
		
}




